# -*- coding: utf-8 -*-
"""Diabetes_UI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m6xIIEvRTAjeC2P77XdwXUESLF5HOV8p
"""

import torch
import torch.nn as nn
import torchvision.models as models
import numpy as np
import pandas as pd
class DiabetesModel(nn.Module):
    def __init__(self):
        super(DiabetesModel, self).__init__()
        self.resnet = models.resnet18(weights='IMAGENET1K_V1')
        self.resnet.fc = nn.Linear(self.resnet.fc.in_features, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.resnet(x)
        x = self.sigmoid(x)
        return x

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = DiabetesModel().to(device)

criterion = nn.BCELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

!pip install gradio torch torchvision

diabetes_model = DiabetesResNet()
diabetes_model.load_state_dict(torch.load('/content/diabetes_model.pth', map_location=torch.device('cpu')))
diabetes_model.eval()

import gradio as gr
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from PIL import Image
import torchvision.models as models

# Define the ResNet Model for Diabetes
class DiabetesResNet(nn.Module):
    def __init__(self):
        super(DiabetesResNet, self).__init__()
        # Load the pre-trained ResNet model (you can use ResNet18, ResNet34, or ResNet50)
        self.resnet = models.resnet18(pretrained=True)  # Using ResNet18, can change to others like ResNet34

        # Modify the final fully connected layer for binary classification (diabetes: 0 or 1)
        self.resnet.fc = nn.Linear(self.resnet.fc.in_features, 1)

    def forward(self, x):
        return torch.sigmoid(self.resnet(x))  # Apply sigmoid for binary output (0 or 1)

# Load the pre-trained ResNet model for diabetes (replace with the correct path to your model)
diabetes_model = DiabetesResNet()
diabetes_model.load_state_dict(torch.load('/content/diabetes_model.pth', map_location=torch.device('cpu')))
diabetes_model.eval()

# Define the function to predict diabetes from retina image
def predict_diabetes(image):
    # Preprocess the image (resize, normalize, and convert to tensor)
    preprocess = transforms.Compose([
        transforms.Resize((224, 224)),  # Resize to match the input size of ResNet
        transforms.ToTensor(),  # Convert image to tensor
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # Normalize image
    ])

    # Apply the transformations to the uploaded image
    image_tensor = preprocess(image).unsqueeze(0)  # Add batch dimension

    with torch.no_grad():
        output = diabetes_model(image_tensor)
        prediction = output.item()  # Get scalar value (0 or 1)
        print(f"Model Output (Raw): {prediction}")  # Debugging: print raw output

    # Return the result
    return "No diabetes" if prediction >= 0.5 else "Has diabetes"

# Create the Gradio interface
interface = gr.Interface(
    fn=predict_diabetes,
    inputs=gr.Image(type="pil", label="Upload Retina Image for Diabetes Prediction"),
    outputs="text"
)

# Launch the Gradio app
interface.launch()